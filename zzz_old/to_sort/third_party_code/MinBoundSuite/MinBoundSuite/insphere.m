function [Center,R] = insphere(xyz,tri)
% insphere: compute the maximal in-sphere of the polyhedronal convex hull of a set of points in R^3
%
% [Center,R] = insphere(xyz)
%    Called with a single nx3 array, insphere treats
%    this as a list of points in 3 dimensions. Each row
%    of xyz is treated as a single point. The convex hull
%    is computed and the maximal in-sphere then computed
%    for the convex hull.
%
% [Center,R] = insphere(xyz,tri)
%    Called with two arguments, the first of which is an
%    nx23 array of data points, and the second a list of
%    facets of the convex hull in 3 dimensions, as would
%    be generated by convhulln, the maximal in-sphere is
%    generated for the hull as provided. No test is made
%    to assure the hull is truly convex when a triangulation
%    was provided.
%
% Either input form returns a row vector of length 3 (C)
% which defines the center of the in-sphere, and the
% radius (R) of the in-sphere.
%
% Example:
% 
% xyz = rand(100,3);
% tri = convhulln(xyz);
% [Center,R] = insphere(xyz,tri)
%
% % Center =
% %      0.50135      0.52118       0.5235
% % R =
% %      0.4717
%
% % Plot the result:
%
% [phi,theta] = meshgrid(linspace(0,2*pi,30),linspace(0,pi,20));
% xs = R*cos(theta).*sin(phi) + Center(1);
% ys = R*sin(theta).*sin(phi) + Center(2);
% zs = R*cos(phi) + Center(3);
% h = surf(xs,ys,zs);
% set(h,'facealpha',.25,'edgecolor','none')
% hold on
% k = unique(tri(:));
% plot3(xyz(k,1),xyz(k,2),xyz(k,3),'o')
% E = [tri(:,1:2);tri(:,[1 3]);tri(:,2:3)];
% h = patch([xyz(E(:,1),1),xyz(E(:,2),1)]', ...
%       [xyz(E(:,1),2),xyz(E(:,2),2)]', ...
%       [xyz(E(:,1),3),xyz(E(:,2),3)]','-');
% set(h,'edgecolor','r','facecolor','none')
% axis equal
% xlabel X
% ylabel Y
% zlabel Z
% title 'Convex hull, with polygon in-sphere'
% grid on
% hold off
%
%
% See also: incircle, minboundcircle, convhulln
%
% Author: John D'Errico
% e-mail: woodchips@rochester.rr.com
% Release: 1.0
% Release date: 6/23/09

if (nargin < 1) || (nargin > 2)
  error('INSPHERE:improperarguments', ...
    'insphere requires exactly 1 or 2 arguments')
elseif (nargin == 1) && (size(xyz,2) == 3)
  % a single list of points as rows of xyz
  tri = convhulln(xyz);
elseif (nargin == 2) && (size(xyz,2) == 3) && (size(tri,2) == 3)
  % y must be a list of edges from convhulln
else
  % none of the forms I allow seem to fit.
  % give up and throw an error.
  error('INSPHERE:invaliddata', ...
    'The arguments do not seem to fit into any of the allowed forms for insphere input')
end
nt = size(tri,1);

% the corner vertices of each facet are...
A = xyz(tri(:,1),:);
B = xyz(tri(:,2),:);
C = xyz(tri(:,3),:);

% the normal vector to each facet
N = cross(B - A, C - A);

% normalize to unit length
L = 1./sqrt(sum(N.^2,2));
N = N.*repmat(L,1,3);

% a central point inside the hull itself
C0 = mean(xyz(tri(:),:),1);

% ensure the normals point inwards. This
% is an efficient test for the facets.
k = sum(N.*bsxfun(@minus,C0,A),2) < 0;
N(k,:) = -N(k,:);

% formulate the linear programming problem.
% given a point C inside the hull, the distance
% from C to the edge that contains A(i,:) is
% given by (dot(N(i,:),C - A(i,:))). If this
% number is negative for any edge of the hull,
% then C is outside of the hull.
%
% Now think of it as a set of slack variables,
% one for each edge of the hull. Given the
% unknown point C that defines the center of
% the in-circle,
%
%  dot(N(i,:),C-A(i,:)) - S(i) == 0
%
% Thus the vector S is of length ne, where ne is
% the number of edges in the convex hull. Every
% element of S must be positive.
%
% Create one more slack variable, a scalar R.
% R is the minimum value that S attains for a
% given point C. 
%
%   R >= 0
%   S(i) >= R
%
% The objective for our linear programming problem
% is simple. It is just -R. When we find the
% solution to the LP problem that satisfies the
% equality constraints above between C and S, the
% bound constraint on T, and the inequality
% constraints between S and R, the solution yields
% the maximal radius in-circle that fits inside
% the convex hull polygon.
%
% The unknowns for the LP are a list of ne+4
% variables. The first two variables represent
% the center coordinates of the circle. X(4) = R
% is the sphere radius. The remainder of the
% variables are the slack variabls S(i).

% equality constraints defined by the dot products
% with the normal vectors.
Aeq = [N,zeros(nt,1),-eye(nt)];
beq = sum(N.*A,2);

% lower bounds only for the slack variables
LB = [-inf; -inf; -inf; 0; zeros(nt,1)];
% there are no upper bounds
UB = [];

% inequalities defined by the slack variable
% constraints
Aineq = [zeros(nt,3),ones(nt,1),-eye(nt)];
bineq = zeros(nt,1);

% the objective is just -R
f = zeros(nt+4,1);
f(4) = -1;

% just turn off the output message
options = optimset('linprog');
options.Display = 'off';

% linprog does all of the hard work.
[result,fval,exitflag] = linprog(f,Aineq,bineq,Aeq,beq,LB,UB,[],options);

switch exitflag
  case 1
    % a valid solution - drop down
  case {0 -7}
    % might have succeeded, but post a warning
    warning('INSPHERE:convergenceissues','Possible convergence issues - degeneracy?')
  case {-2 -3 -4 -5}
    error('INSPHERE:degeneracyencountered','Algorithm failure - degeneracy found')
end

% unpack the circle parameters
Center = result(1:3)';
R = result(4);

